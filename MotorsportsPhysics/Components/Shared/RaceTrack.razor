@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using System.Threading
@implements IAsyncDisposable
@inject IJSRuntime JS

<div class="relative w-full max-w-5xl mx-auto rounded-lg overflow-hidden shadow-lg @Class" style="aspect-ratio: 16 / 9;">
  <div class="absolute inset-0">
    <svg @ref="svg" viewBox="0 0 800 450" class="w-full h-full">
      <image href="images/track.png" x="0" y="0" width="800" height="450" preserveAspectRatio="none"/>
  <path id="racePath"
    d="@(string.IsNullOrWhiteSpace(PathDOverride) ? PathD : PathDOverride)"
    fill="none"
    stroke="@PathColor"
    stroke-width="@((ShowPath ? PathWidth : 0).ToString(System.Globalization.CultureInfo.InvariantCulture))"
    stroke-opacity="@((ShowPath ? PathOpacity : 0).ToString(System.Globalization.CultureInfo.InvariantCulture))"
    stroke-dasharray="@(ShowPath && !string.IsNullOrEmpty(PathDashArray) ? PathDashArray : null)"
    transform="@(((PathScaleX != 1.0 || PathScaleY != 1.0) && PathScale == 1.0 && PathTranslateX == 0 && PathTranslateY == 0)
      ? $"scale({PathScaleX.ToString(System.Globalization.CultureInfo.InvariantCulture)} {PathScaleY.ToString(System.Globalization.CultureInfo.InvariantCulture)})"
      : null)" />
      <!-- Secondary lane path (same styling/visibility) -->
      <path id="racePath2"
        d="@PathD2"
        fill="none"
        stroke="@PathColor"
        stroke-width="@((ShowPath ? PathWidth : 0).ToString(System.Globalization.CultureInfo.InvariantCulture))"
        stroke-opacity="@((ShowPath ? PathOpacity : 0).ToString(System.Globalization.CultureInfo.InvariantCulture))"
        stroke-dasharray="@(ShowPath && !string.IsNullOrEmpty(PathDashArray) ? PathDashArray : null)"
        transform="@(((PathScaleX != 1.0 || PathScaleY != 1.0) && PathScale == 1.0 && PathTranslateX == 0 && PathTranslateY == 0)
          ? $"scale({PathScaleX.ToString(System.Globalization.CultureInfo.InvariantCulture)} {PathScaleY.ToString(System.Globalization.CultureInfo.InvariantCulture)})"
          : null)" />
      @if (Cars?.Any() == true)
      {
        var idx = 0;
        foreach (var car in Cars!)
        {
          if (idx == 0)
          {
            <image id="carSprite" class="carSprite" href="@car.Src" width="@car.Width" height="@car.Height" data-offset="@car.Offset.ToString(System.Globalization.CultureInfo.InvariantCulture)" data-grid-dx="@car.GridDx.ToString(System.Globalization.CultureInfo.InvariantCulture)" data-grid-dy="@car.GridDy.ToString(System.Globalization.CultureInfo.InvariantCulture)" data-lane="@car.Lane" />
          }
          else
          {
            <image class="carSprite" href="@car.Src" width="@car.Width" height="@car.Height" data-offset="@car.Offset.ToString(System.Globalization.CultureInfo.InvariantCulture)" data-grid-dx="@car.GridDx.ToString(System.Globalization.CultureInfo.InvariantCulture)" data-grid-dy="@car.GridDy.ToString(System.Globalization.CultureInfo.InvariantCulture)" data-lane="@car.Lane" />
          }
          idx++;
        }
      }
      else
      {
        <image id="carSprite" class="carSprite" href="images/car.png" width="70" height="40" />
      }
    </svg>
  </div>
  @if (ShowSpeed)
  {
    <div class="absolute top-3 right-3 bg-black/60 text-white rounded-md px-3 py-1 text-sm shadow-md select-none race-speed-badge flex items-center gap-3">
      <div>
        <span class="opacity-80 mr-1">Speed:</span>
        <span class="font-semibold">@_speedDisplay</span>
        <span class="opacity-70 ml-1">px/s</span>
      </div>
      <div class="opacity-60">|</div>
      <div>
        <span class="opacity-80 mr-1">Lap:</span>
        <span class="font-semibold">@_lapDisplay</span>
      </div>
    </div>
  }
  @if (!string.IsNullOrEmpty(Title))
  {
    <div class="absolute bottom-0 left-0 p-6 text-white pointer-events-none">
      <h2 class="text-3xl sm:text-4xl font-bold race-title">@Title</h2>
    </div>
  }
</div>

@code {
  [Parameter] public string Class { get; set; } = string.Empty;
  [Parameter] public string Title { get; set; } = "";
  [Parameter] public IEnumerable<CarSprite>? Cars { get; set; }
  [Parameter] public int Speed { get; set; } = 180;
  [Parameter] public bool ShowSpeed { get; set; } = true;
  [Parameter] public double StartRotation { get; set; } = 270;
  [Parameter] public double AngleSmoothing { get; set; } = 0.18;
  // Shift initial position along the path by a fraction of total length (-1..1). Positive moves forward; negative moves earlier/back.
  [Parameter] public double StartOffsetFraction { get; set; } = 0.094;
  // Start/acceleration behavior
  // Stationary on load, wait this many seconds, then accelerate to Speed over AccelerationSeconds
  [Parameter] public double StartDelaySeconds { get; set; } = 1.2;
  [Parameter] public double AccelerationSeconds { get; set; } = 2.5;
  // If false, do not auto-start the animation on first render; caller must invoke StartAsync
  [Parameter] public bool AutoStart { get; set; } = true;
  // Optional: override the default path and apply scaling to map external coordinate systems into 800x450
  [Parameter] public string? PathDOverride { get; set; }
  [Parameter] public double PathScaleX { get; set; } = 10.0;
  [Parameter] public double PathScaleY { get; set; } = 1.0;
  // Path visibility & styling (visible by default for debugging)
  [Parameter] public bool ShowPath { get; set; } = false;
  [Parameter] public double PathWidth { get; set; } = 2.0;
  [Parameter] public double PathOpacity { get; set; } = 0.7;
  [Parameter] public string PathColor { get; set; } = "#00bcd4";
  [Parameter] public string? PathDashArray { get; set; } = "6 10";
  // Whether the current quiz question has been answered (controls if animation halts on lap events)
  [Parameter] public bool QuestionAnswered { get; set; } = false;
  // Number of questions answered so far; used to gate lap passing
  [Parameter] public int AnsweredCount { get; set; } = 0;
  // Bubble up lap changes to parent if needed
  [Parameter] public EventCallback<int> OnLapChangedEvent { get; set; }

  private ElementReference svg;
  private IJSObjectReference? _module;
  private IJSObjectReference? _anim;
  private CancellationTokenSource? _cts;
  private bool _started = false;
  private DotNetObjectReference<RaceTrack>? _selfRef;
  private int _speedCurrent = 0;
  private string _speedDisplay => _speedCurrent.ToString(System.Globalization.CultureInfo.InvariantCulture);
  private int _lapCurrent = 0;
  private string _lapDisplay => (_lapCurrent + 1).ToString(System.Globalization.CultureInfo.InvariantCulture);

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (!firstRender) return;
  _module = await JS.InvokeAsync<IJSObjectReference>("import", "/js/trackSim.js?v=18");
  _anim = await _module.InvokeAsync<IJSObjectReference>("init", svg, new { speed = this.Speed, startRotation = this.StartRotation, angleSmoothing = this.AngleSmoothing, startOffsetFrac = this.StartOffsetFraction, showStartMarker = this.ShowStartMarker });
    // Apply optional transform so the path and cars align
    if (_anim is not null && (PathTranslateX != 0 || PathTranslateY != 0 || Math.Abs(PathScale - 1.0) > double.Epsilon))
    {
      await _anim.InvokeVoidAsync("setTransform", PathTranslateX, PathTranslateY, PathScale);
    }
    if (_anim is not null)
    {
      // Always register listeners
      _selfRef = DotNetObjectReference.Create(this);
      try { await _anim.InvokeVoidAsync("registerSpeedListener", _selfRef); } catch { }
      try { await _anim.InvokeVoidAsync("registerLapListener", _selfRef); } catch { }
      _started = true;
      // Sync initial answered state
      await _anim.InvokeVoidAsync("setQuestionAnswered", QuestionAnswered);
      await _anim.InvokeVoidAsync("setAnsweredCount", AnsweredCount);
      // Start only if AutoStart is true
      if (AutoStart)
      {
        // Start playing at speed 0 so the car remains stationary during delay/ramp
        await _anim.InvokeVoidAsync("setSpeed", 0);
        await _anim.InvokeVoidAsync("play");
        _cts = new CancellationTokenSource();
        _ = StartWithRampAsync(_cts.Token);
      }
    }
  }

  private async Task StartWithRampAsync(CancellationToken ct, double? targetSpeedOverride = null)
  {
    try
    {
      // Optional initial delay
      var delayMs = (int)Math.Max(0, StartDelaySeconds * 1000);
      if (delayMs > 0)
      {
        await Task.Delay(delayMs, ct);
      }

      // If no ramp duration, jump to target speed
      if (AccelerationSeconds <= 0)
      {
        if (_anim is not null)
        {
          var finalSpeed = targetSpeedOverride ?? Speed;
          await _anim.InvokeVoidAsync("setSpeed", finalSpeed);
        }
        return;
      }

      // Smooth acceleration to target using ease-in cubic (t^3)
      var duration = TimeSpan.FromSeconds(AccelerationSeconds);
      // 30 steps per second is smooth enough while minimizing interop
      var steps = Math.Max(1, (int)Math.Round(AccelerationSeconds * 30));
      var stepDelay = TimeSpan.FromSeconds(AccelerationSeconds / steps);
      var target = targetSpeedOverride ?? Speed;
      for (int i = 1; i <= steps; i++)
      {
        ct.ThrowIfCancellationRequested();
        double t = (double)i / steps; // 0..1
        double eased = t * t * t; // ease-in cubic
        double current = target * eased;
        if (_anim is not null)
        {
          await _anim.InvokeVoidAsync("setSpeed", current);
        }
        if (i < steps)
        {
          await Task.Delay(stepDelay, ct);
        }
      }
      // Ensure we end exactly at target
      if (_anim is not null)
      {
        await _anim.InvokeVoidAsync("setSpeed", target);
      }
    }
    catch (OperationCanceledException)
    {
      // ignored
    }
  }

  public async ValueTask DisposeAsync()
  {
    try
    {
      _cts?.Cancel();
    }
    catch { }
    finally
    {
      _cts?.Dispose();
      _cts = null;
    }
    if (_anim is not null)
    {
      try { await _anim.InvokeVoidAsync("unregisterSpeedListener"); } catch { }
      try { await _anim.InvokeVoidAsync("unregisterLapListener"); } catch { }
      try { await _anim.InvokeVoidAsync("dispose"); } catch { }
    }
    if (_module is not null)
    {
      try { await _module.DisposeAsync(); } catch { }
    }
    _selfRef?.Dispose();
    _selfRef = null;
  }

  public record CarSprite(string Src, double Width = 70, double Height = 40, double Offset = 0, double GridDx = 0, double GridDy = 0, int Lane = 1);

  [Parameter] public bool ShowStartMarker { get; set; } = false;

  private string PathD =
    "M612.508 423.151C438.898 431.914 342.384 437.99 157.525 430.869L105.314 425.08C75.8902 420.87 59.5932 415.586 30.7261 403.212L2.24728 372.338C-0.27815 353.794 0.792105 343.641 7.67182 326.028C12.3987 316.855 17.2131 311.847 35.4726 303.516C52.7043 299.586 62.4797 297.497 89.718 303.516C101.939 305.194 112.634 312.46 139.895 338.892C186.892 355.437 189.833 355.243 196.853 355.615C225.262 355.854 241.088 356.2 271.44 352.399C288.644 345.87 298.524 342.547 312.802 331.817C323.327 322.255 329.179 316.875 336.535 306.089C340.464 295.428 342.557 289.419 345.35 278.432C348.644 263.111 348.231 253.314 345.35 234.694C336.411 223.188 329.636 217.788 316.193 208.966C301.988 200.751 291.955 196.688 270.762 190.314C238.172 177.054 220.704 168.949 192.106 152.365C181.637 146.763 176.722 142.797 171.764 132.426V111.201V75.8249C175.638 56.9734 179.604 47.1064 198.209 34.0172C229.62 14.5551 250.567 9.50283 289.07 2.50056C322.807 -0.953666 340.821 2.07071 373.15 6.35973C386.721 10.1824 394.257 12.7043 407.054 20.51C417.914 27.5802 425.656 33.3101 438.245 48.8107C446.837 60.4237 448.531 66.6711 451.806 79.6841C452.001 123.435 453.647 147.742 461.977 190.314C467.046 203.524 471.306 210.829 480.285 223.76C492.701 243.258 502.201 247.655 506.73 248.201C556.392 258.079 583.992 263.118 632.851 271.356C652.515 279.189 676.673 291.56 685.062 296.441C693.451 301.322 696.107 303.287 699.979 312.521C700.986 324.059 701.654 330.603 699.979 340.178C696.576 355.747 693.369 364.21 685.062 378.77C677.865 392.185 672.803 399.039 659.295 408.357C642.011 417.222 631.877 420.803 612.508 423.151Z";
  // Uniform scale and translation applied via JS so cars follow the transformed path visually
  [Parameter] public double PathScale { get; set; } = 0.77;
  [Parameter] public double PathTranslateX { get; set; } = 130.0;
  [Parameter] public double PathTranslateY { get; set; } = 39.0;

  // Secondary lane path data (before transform). Uses the provided alternate SVG path.
  private string PathD2 =
    "M612.508 423.151C438.898 431.914 342.384 437.99 157.525 430.869L105.314 425.08C75.8902 420.87 59.5932 415.586 30.7261 403.212C12.8274 390.524 7.28976 383.829 2.24728 372.338C-0.27815 353.794 0.792105 343.641 7.67182 326.028C12.3987 316.855 17.2131 311.847 35.4726 303.516C52.7043 299.586 62.4797 297.497 89.718 303.516C96.542 306.243 106.791 307.804 146.5 331.817C166.384 343.332 177.263 349.483 198 352.399C226.409 352.638 241.088 356.2 271.44 352.399C288.644 345.87 298.524 342.547 312.802 331.817C323.327 322.255 329.179 316.875 336.535 306.089C340.464 295.427 342.557 289.419 345.35 278.432C348.644 263.111 348.231 253.314 345.35 234.694C336.411 223.188 329.636 217.788 316.193 208.966C301.988 200.751 291.955 196.688 270.762 190.314C238.172 177.054 220.704 168.949 192.106 152.365C181.637 146.763 176.722 142.797 171.764 132.426C166.247 122.447 164.651 116.989 164.5 107.5C161.777 93.8316 162.108 86.1684 164.5 72.5C168.373 53.6485 179.604 47.1064 198.209 34.0172C229.62 14.5551 250.567 9.50283 289.07 2.50056C322.807 -0.953666 340.821 2.07071 373.15 6.35973C383.933 9.79361 389.701 12.0692 407.054 20.51C415.291 26.2583 427.178 28.946 435.5 51.5C435.5 51.5 438.245 79 438.245 89V89.2674C438.244 99.6772 438.242 138.298 446.5 180.5C451.569 193.71 452.998 202.069 461.977 215C475.653 234.694 482.5 241 506.73 248.201C556.392 258.079 563.65 191.762 612.508 200C642.5 200 670.871 211.259 679.5 215C688.129 218.741 717.89 252.019 721.5 262.5C722.437 266.717 733.419 294.747 729 312.521C727.811 327.883 723.501 348.23 713 363C705.916 376.205 673.832 398.332 659.945 407.909L659.295 408.357C642.011 417.222 631.877 420.803 612.508 423.151Z";

  // Public control methods for parent components
  public async Task PlayLapsAsync(int laps, int? speed = null, bool haltOnFinish = true)
  {
    if (_anim is null) return;
    var s = speed ?? this.Speed;
    // If not yet started, apply optional start delay + ramp; otherwise keep current speed to avoid flicker
    if (!_started)
    {
      if (StartDelaySeconds > 0 || AccelerationSeconds > 0)
      {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();
        _ = StartWithRampAsync(_cts.Token, s);
      }
      else
      {
        await _anim.InvokeVoidAsync("setSpeed", s);
      }
    }
    else if (speed.HasValue)
    {
      // If already running and a specific speed is requested, set it immediately (no ramp)
      await _anim.InvokeVoidAsync("setSpeed", s);
    }
    // playForLaps will ensure playing and only count distance; target speed will be applied by the ramp
    await _anim.InvokeVoidAsync("playForLaps", laps, s, haltOnFinish);
    _started = true;
  }

  protected override async Task OnParametersSetAsync()
  {
    if (_anim is not null)
    {
      try { await _anim.InvokeVoidAsync("setQuestionAnswered", QuestionAnswered); } catch { }
      try { await _anim.InvokeVoidAsync("setAnsweredCount", AnsweredCount); } catch { }
    }
  }

  [JSInvokable]
  public Task OnSpeedChanged(int speed)
  {
    _speedCurrent = speed;
    if (ShowSpeed)
    {
      try { InvokeAsync(StateHasChanged); } catch { }
    }
    return Task.CompletedTask;
  }

  [JSInvokable]
  public Task OnLapChanged(int lap)
  {
    _lapCurrent = lap;
    if (ShowSpeed)
    {
      try { InvokeAsync(StateHasChanged); } catch { }
    }
    try { if (OnLapChangedEvent.HasDelegate) _ = OnLapChangedEvent.InvokeAsync(lap); } catch { }
    return Task.CompletedTask;
  }

  // Apply a temporary speed penalty: multiplier (0..1] applied for durationMs, then restored
  public async Task ApplyPenaltyAsync(double multiplier, int durationMs)
  {
    if (_anim is null) return;
    var m = Math.Max(0.0, Math.Min(1.0, multiplier));
    var d = Math.Max(0, durationMs);
    await _anim.InvokeVoidAsync("applyPenalty", m, d);
  }

  // Apply a penalty that lasts until the next completed lap (ignores duration)
  public async Task ApplyPenaltyForNextLapAsync(double multiplier)
  {
    if (_anim is null) return;
    var m = Math.Max(0.0, Math.Min(1.0, multiplier));
    await _anim.InvokeVoidAsync("applyPenaltyForNextLap", m);
  }

  // Adjust the constant base speed by a delta (positive or negative)
  public async Task AdjustBaseSpeedAsync(double delta)
  {
    if (_anim is null) return;
    await _anim.InvokeVoidAsync("adjustBaseSpeed", delta);
  }

  // Public start entry: ensure playing and run the configured delay + ramp to current Speed
  public async Task StartAsync(double? targetSpeed = null)
  {
    if (_anim is null) return;
    try { _cts?.Cancel(); } catch { }
    _cts = new CancellationTokenSource();
    // Set initial speed 0 and play; StartWithRampAsync will ramp after StartDelaySeconds
    await _anim.InvokeVoidAsync("setSpeed", 0);
    await _anim.InvokeVoidAsync("play");
    _ = StartWithRampAsync(_cts.Token, targetSpeed);
  }

  // Public stop entry: immediately set speed to 0 and pause the animation
  public async Task StopAsync()
  {
    if (_anim is null) return;
    try { _cts?.Cancel(); } catch { }
    await _anim.InvokeVoidAsync("setSpeed", 0);
    await _anim.InvokeVoidAsync("pause");
  }
}
