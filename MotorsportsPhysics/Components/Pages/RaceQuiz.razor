@page "/race-quiz"
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.AspNetCore.Components.Web
@using MotorsportsPhysics.Components.Pages
@using MotorsportsPhysics.Components.Shared
@inject IJSRuntime JS

<PageTitle>Race Quiz</PageTitle>

@if (!_configured)
{
  <div class="container mx-auto max-w-3xl px-4 sm:px-6 lg:px-8 py-10">
    <p class="text-gray-700">Loading…</p>
  </div>
}
else
{
  <div class="container mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8">
    <div class="mb-4 text-sm text-gray-600">
      <a class="text-primary hover:underline" href="/race-menu">Back to difficulty</a>
      <span class="mx-2">/</span>
      <span>Mode: <strong>@_label</strong></span>
    </div>
      @if (_showAnim)
      {
        @if (_isEasy)
        {
          <EasyRace @ref="_easyRace" QuestionAnswered="@_questionAnswered" AnsweredCount="@_answeredCount" OnLapChanged="OnLapChanged" />
        }
        else
        {
          <MediumRace @ref="_mediumRace" QuestionAnswered="@_questionAnswered" AnsweredCount="@_answeredCount" OnLapChanged="OnLapChanged" />
        }
      }
  <CorneringQuiz @ref="_quizRef" StepMode="true" AutoStart="false" OnFinished="OnQuizFinished"
                   ShowExplanation="@_showExplanation"
                   RaceMode="@_raceMode"
                   Timed="@_timed"
                   TimeLimitSeconds="@_timeLimit"
                   OnStepStarted="OnStepStarted"
                   OnAnswerStateChanged="OnAnswerStateChanged"
                   OnAnswerChecked="OnAnswerChecked"
                   OnAnsweredCountChanged="OnAnsweredCountChanged" />

    @if (_showDisclaimer)
    {
      <div class="fixed inset-0 z-40 flex items-center justify-center bg-black/50">
        <div class="max-w-lg w-[92%] rounded-lg bg-white shadow-xl p-6">
          <h2 class="text-xl font-bold mb-3">How to play</h2>
          <ul class="list-disc pl-5 text-gray-800 space-y-2 mb-4">
            <li>Watch the car as it drives around the track. Answer the question shown for each step.</li>
            <li>When you answer incorrectly in Easy mode, your car gets a temporary speed penalty.</li>
            <li>Improve your pace by answering correctly — speed ramps up every lap.</li>
          </ul>
          <p class="text-gray-700 mb-5">Click OK to begin. The car will start after a short countdown.</p>
          <div class="flex justify-end gap-2">
            <button class="rounded-md border px-4 py-2" @onclick="() => _showDisclaimer = false">Cancel</button>
            <button class="rounded-md bg-primary text-white px-4 py-2" @onclick="BeginQuizAndRace">OK, let’s go</button>
          </div>
        </div>
      </div>
    }

    @if (_grandPrixFinished)
    {
      <div class="fixed inset-0 z-30 flex items-center justify-center bg-black/60">
        <div class="rounded-xl bg-white shadow-2xl p-8 max-w-md w-[92%] text-center">
          <h2 class="text-2xl font-extrabold mb-2">Grand Prix finished</h2>
          <p class="text-gray-700 mb-4">Congratulations! You’ve completed all laps and questions.</p>
          <p class="text-gray-600">The car is no longer riding.</p>
          <div class="mt-6 flex justify-center">
            <button class="rounded-md bg-primary text-white px-6 py-2 font-semibold" @onclick="() => _grandPrixFinished = false">OK</button>
          </div>
        </div>
      </div>
    }
  </div>
}

@code {
  [Inject] public NavigationManager Nav { get; set; } = default!;

  private bool _configured = false;
  private bool _showExplanation = true;
  private bool _raceMode = false;
  private bool _timed = false;
  private int _timeLimit = 90;
  private string _label = "";
  private bool _isEasy = false;
    private bool _showAnim = false;
  private EasyRace? _easyRace;
  private MediumRace? _mediumRace;
  private CorneringQuiz? _quizRef;
  private bool _questionAnswered = false;
  private int _answeredCount = 0;
  private bool _showDisclaimer = true;
  private bool _quizFinished = false;
  private int _lastLapSeen = 0;
  private bool _grandPrixFinished = false;
  private DateTime? _raceStartedUtc;
  private DateTime? _raceFinishedUtc;
  private DateTime? _quizFinishedUtc;


  protected override void OnInitialized()
  {
    var uri = Nav.ToAbsoluteUri(Nav.Uri);
    var query = QueryHelpers.ParseQuery(uri.Query);
    var difficulty = query.TryGetValue("difficulty", out var v) ? v.ToString() : "easy";
    switch (difficulty.ToLowerInvariant())
    {
      case "easy":
        _showExplanation = true;
        _raceMode = false;
        _timed = false;
        _timeLimit = 0;
        _label = "Easy";
        _isEasy = true;
  _showAnim = true;
        break;
      case "medium":
        _showExplanation = true;
        _raceMode = true;
        _timed = false;
        _timeLimit = 0;
        _label = "Medium";
        _isEasy = false;
          _showAnim = true;
        break;
      case "high":
        _showExplanation = false;
        _raceMode = true;
        _timed = true;
        _timeLimit = 120;
        _label = "High";
        _isEasy = false;
          _showAnim = true;
        break;
      default:
        _showExplanation = true;
        _raceMode = false;
        _timed = false;
        _timeLimit = 0;
        _label = "Easy";
        _isEasy = true;
        _showAnim = true;
        break;
    }
    _configured = true;
  }

  // RaceTrack handles its own JS init
  private async Task OnStepStarted(int step)
  {
    _raceStartedUtc ??= DateTime.UtcNow;
    if (_isEasy && _easyRace is not null)
    {
      await _easyRace.StartStepAsync(step);
    }
  }

  private Task OnAnswerStateChanged(bool answered)
  {
    _questionAnswered = answered;
    StateHasChanged();
    return Task.CompletedTask;
  }

  private Task OnAnsweredCountChanged(int count)
  {
    _answeredCount = count;
    StateHasChanged();
    return Task.CompletedTask;
  }

  private async Task OnAnswerChecked(bool correct)
  {
    // Case 1 (correct): increase base speed a bit
    if (_isEasy && _easyRace is not null && correct)
    {
      await _easyRace.AdjustBaseSpeedAsync(+15); // tune as desired
    }
    // Case 2 (wrong): decrease speed for the remainder of the current lap
    else if (_isEasy && _easyRace is not null && !correct)
    {
      await _easyRace.ApplyPenaltyForNextLapAsync(multiplier: 0.85); // 15% slow for rest of lap
    }
  }

  private Task OnQuizFinished()
  {
    _quizFinishedUtc = DateTime.UtcNow;
    // If the car has already completed the final lap (lapCounter >= answered count), reveal immediately
    if (_answeredCount > 0 && _lastLapSeen >= _answeredCount)
    {
      // Compute max(quiz, car)
      var quizElapsed = (_raceStartedUtc.HasValue && _quizFinishedUtc.HasValue) ? (_quizFinishedUtc.Value - _raceStartedUtc.Value) : TimeSpan.Zero;
      var carElapsed = (_raceStartedUtc.HasValue && _raceFinishedUtc.HasValue) ? (_raceFinishedUtc.Value - _raceStartedUtc.Value) : quizElapsed;
      var maxElapsed = quizElapsed > carElapsed ? quizElapsed : carElapsed;
      try { _quizRef?.RevealElapsedWith(maxElapsed); } catch { }
      // Ensure car is stopped and overlay is shown if needed
      _ = StopCarAsync();
      _grandPrixFinished = true;
      StateHasChanged();
      _quizFinished = false;
    }
    else
    {
      _quizFinished = true; // wait for OnLapChanged to signal the final crossing
    }
    return Task.CompletedTask;
  }

  private Task OnLapChanged(int lap)
  {
    _lastLapSeen = lap;
    // When the quiz is finished, wait for exactly 'AnsweredCount' laps to be completed, then mark race finished
    // Note: lap is 0-based internally; AnsweredCount is the number of questions answered (1-based threshold)
    if (_quizFinished && _answeredCount > 0 && lap >= _answeredCount)
    {
      _quizFinished = false; // prevent duplicate calls
      _raceFinishedUtc ??= DateTime.UtcNow;
      // Compute max(quiz, car)
      var quizElapsed = (_raceStartedUtc.HasValue && _quizFinishedUtc.HasValue) ? (_quizFinishedUtc.Value - _raceStartedUtc.Value) : TimeSpan.Zero;
      var carElapsed = (_raceStartedUtc.HasValue && _raceFinishedUtc.HasValue) ? (_raceFinishedUtc.Value - _raceStartedUtc.Value) : quizElapsed;
      var maxElapsed = quizElapsed > carElapsed ? quizElapsed : carElapsed;
      try { _quizRef?.RevealElapsedWith(maxElapsed); } catch { }
      // Stop the car and show the finish overlay
      _ = StopCarAsync();
      _grandPrixFinished = true;
      StateHasChanged();
    }
    return Task.CompletedTask;
  }

  private async Task StopCarAsync()
  {
    try
    {
      if (_isEasy && _easyRace is not null) await _easyRace.StopAsync();
      else if (!_isEasy && _mediumRace is not null) await _mediumRace.StopAsync();
    }
    catch { }
  }

  private async Task BeginQuizAndRace()
  {
    _showDisclaimer = false;
    StateHasChanged();
    // Defer to next render to ensure overlays are gone before starting
    await Task.Yield();
    // Start the quiz flow; it will trigger OnStepStarted(1) and then start the race step via _easyRace
    _quizRef?.StartFromParent();
    _raceStartedUtc ??= DateTime.UtcNow;
  }
}
