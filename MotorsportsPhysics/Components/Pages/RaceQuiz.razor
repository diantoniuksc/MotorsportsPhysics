@page "/race-quiz"
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.AspNetCore.Components.Web
@using MotorsportsPhysics.Components.Pages
@using MotorsportsPhysics.Components.Shared
@inject IJSRuntime JS

<PageTitle>Race Quiz</PageTitle>

@if (!_configured)
{
  <div class="container mx-auto max-w-3xl px-4 sm:px-6 lg:px-8 py-10">
    <p class="text-gray-700">Loading…</p>
  </div>
}
else
{
  <div class="container mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8">
    <div class="mb-4 text-sm text-gray-600">
      <a class="text-primary hover:underline" href="/race-menu">Back to difficulty</a>
      <span class="mx-2">/</span>
      <span>Mode: <strong>@_label</strong></span>
    </div>
      @if (_showAnim)
      {
        @if (_isEasy)
        {
          <EasyRace @ref="_easyRace" QuestionAnswered="@_questionAnswered" AnsweredCount="@_answeredCount" OnLapChanged="OnLapChanged" GateByAnsweredCount="true" />
        }
        else
        {
          <MediumRace @ref="_mediumRace" QuestionAnswered="@_questionAnswered" AnsweredCount="@_answeredCount" OnLapChanged="OnLapChanged" GateByAnsweredCount="false" />
        }
      }
  <CorneringQuiz @ref="_quizRef" StepMode="true" AutoStart="false" OnFinished="OnQuizFinished"
                   ShowExplanation="@_showExplanation"
                   RaceMode="@_raceMode"
                   Timed="@_timed"
                   TimeLimitSeconds="@_timeLimit"
                   RivalLabels="@_rivalLabels"
                   OnStepStarted="OnStepStarted"
                   OnAnswerStateChanged="OnAnswerStateChanged"
                   OnAnswerChecked="OnAnswerChecked"
                   OnAnsweredCountChanged="OnAnsweredCountChanged" />

    @if (_showDisclaimer)
    {
      <div class="fixed inset-0 z-40 flex items-center justify-center bg-black/50">
        <div class="max-w-lg w-[92%] rounded-lg bg-white shadow-xl p-6">
          <h2 class="text-xl font-bold mb-3">How to play</h2>
          <ul class="list-disc pl-5 text-gray-800 space-y-2 mb-4">
            <li>Watch the car as it drives around the track. Answer the question shown for each step.</li>
            <li>When you answer incorrectly in Easy mode, your car gets a temporary speed penalty.</li>
            <li>Improve your pace by answering correctly — speed ramps up every lap.</li>
          </ul>
          <p class="text-gray-700 mb-5">Click OK to begin. The car will start after a short countdown.</p>
          <div class="flex justify-end gap-2">
            <button class="rounded-md border px-4 py-2" @onclick="() => _showDisclaimer = false">Cancel</button>
            <button class="rounded-md bg-primary text-white px-4 py-2" @onclick="BeginQuizAndRace">OK, let’s go</button>
          </div>
        </div>
      </div>
    }

    @if (_grandPrixFinished)
    {
      <div class="fixed inset-0 z-30 flex items-center justify-center bg-black/60">
        <div class="rounded-xl bg-white shadow-2xl p-8 max-w-md w-[92%] text-center">
          <h2 class="text-2xl font-extrabold mb-2">Grand Prix finished</h2>
          <p class="text-gray-700 mb-4">Congratulations! You’ve completed all laps and questions.</p>
          <p class="text-gray-700 mb-2">Your position: <strong>@_finalPosition</strong> / @_finalTotalCars</p>
          <p class="text-gray-600">The car is no longer riding.</p>
          <div class="mt-6 flex justify-center">
            <button class="rounded-md bg-primary text-white px-6 py-2 font-semibold" @onclick="() => _grandPrixFinished = false">OK</button>
          </div>
        </div>
      </div>
    }
  </div>
}

@code {
  [Inject] public NavigationManager Nav { get; set; } = default!;

  private bool _configured = false;
  private bool _showExplanation = true;
  private bool _raceMode = false;
  private bool _timed = false;
  private int _timeLimit = 90;
  private string _label = "";
  private bool _isEasy = false;
    private bool _showAnim = false;
  private EasyRace? _easyRace;
  private MediumRace? _mediumRace;
  private CorneringQuiz? _quizRef;
  private bool _questionAnswered = false;
  private int _answeredCount = 0;
  private bool _showDisclaimer = true;
  private bool _quizFinished = false;
  private int _lastLapSeen = 0;
  private bool _grandPrixFinished = false;
  private DateTime? _raceStartedUtc;
  private DateTime? _raceFinishedUtc;
  private DateTime? _quizFinishedUtc;
  private int _finalPosition = 1;
  private int _finalTotalCars = 1;
  private string[] _rivalLabels = System.Array.Empty<string>();
  private List<RaceTrack.LapTelemetry> _telemetry = new();
  private CancellationTokenSource? _progressPumpCts;
  private const double WrongAnswerPenaltyDelta = -30; // px/s (milder penalty)


  protected override void OnInitialized()
  {
    var uri = Nav.ToAbsoluteUri(Nav.Uri);
    var query = QueryHelpers.ParseQuery(uri.Query);
    var difficulty = query.TryGetValue("difficulty", out var v) ? v.ToString() : "easy";
    switch (difficulty.ToLowerInvariant())
    {
      case "easy":
        _showExplanation = true;
        _raceMode = false;
        _timed = false;
        _timeLimit = 0;
        _label = "Easy";
        _isEasy = true;
  _showAnim = true;
        break;
      case "medium":
        _showExplanation = true;
        _raceMode = true;
        _timed = false;
        _timeLimit = 0;
        _label = "Medium";
        _isEasy = false;
          _showAnim = true;
        _rivalLabels = new [] { "Blue", "Green", "Purple", "Orange", "Pink" };
        break;
      case "high":
        _showExplanation = false;
        _raceMode = true;
        _timed = true;
        _timeLimit = 120;
        _label = "High";
        _isEasy = false;
          _showAnim = true;
        _rivalLabels = new [] { "Blue", "Green", "Purple", "Orange", "Pink" };
        break;
      default:
        _showExplanation = true;
        _raceMode = false;
        _timed = false;
        _timeLimit = 0;
        _label = "Easy";
        _isEasy = true;
        _showAnim = true;
        _rivalLabels = System.Array.Empty<string>();
        break;
    }
    _configured = true;
  }

  // RaceTrack handles its own JS init
  private async Task OnStepStarted(int step)
  {
    _raceStartedUtc ??= DateTime.UtcNow;
    if (_isEasy && _easyRace is not null)
    {
      try { await _easyRace.ResetLapTelemetryAsync(); } catch { }
      try { await _easyRace.SetTargetLapsAsync(_quizRef?.GetTotalSteps() ?? step); } catch { }
      await _easyRace.StartStepAsync(step);
    }
    else if (!_isEasy && _mediumRace is not null)
    {
      try { await _mediumRace.ResetLapTelemetryAsync(); } catch { }
      try { await _mediumRace.SetTargetLapsAsync(_quizRef?.GetTotalSteps() ?? step); } catch { }
      await _mediumRace.StartStepAsync(step);
    }
    _ = UpdateProgressBarsFromRaceAsync();
  }

  private Task OnAnswerStateChanged(bool answered)
  {
    _questionAnswered = answered;
    StateHasChanged();
    return Task.CompletedTask;
  }

  private Task OnAnsweredCountChanged(int count)
  {
    _answeredCount = count;
    StateHasChanged();
    return Task.CompletedTask;
  }

  private async Task OnAnswerChecked(bool correct)
  {
    // Correct answer: increase base speed immediately (Easy & Medium)
    if (correct)
    {
      if (_isEasy && _easyRace is not null)
      {
        await _easyRace.AdjustBaseSpeedAsync(+35);
      }
      else if (!_isEasy && _mediumRace is not null)
      {
        await _mediumRace.AdjustBaseSpeedAsync(+35);
      }
    }
    // Incorrect answer: set absolute base speed to 50 px/s (Easy & Medium)
    else
    {
      if (_isEasy && _easyRace is not null)
      {
        await _easyRace.AdjustBaseSpeedAsync(WrongAnswerPenaltyDelta);
      }
      else if (!_isEasy && _mediumRace is not null)
      {
        await _mediumRace.AdjustBaseSpeedAsync(WrongAnswerPenaltyDelta);
      }
    }
  }

  private Task OnQuizFinished()
  {
    _quizFinishedUtc = DateTime.UtcNow;
    if (_answeredCount > 0 && _lastLapSeen >= _answeredCount)
    {
      var quizElapsed = (_raceStartedUtc.HasValue && _quizFinishedUtc.HasValue) ? (_quizFinishedUtc.Value - _raceStartedUtc.Value) : TimeSpan.Zero;
      var carElapsed = (_raceStartedUtc.HasValue && _raceFinishedUtc.HasValue) ? (_raceFinishedUtc.Value - _raceStartedUtc.Value) : quizElapsed;
      var maxElapsed = quizElapsed > carElapsed ? quizElapsed : carElapsed;
      try { _quizRef?.RevealElapsedWith(maxElapsed); } catch { }
      _grandPrixFinished = true;
  StopProgressPump();
      _ = StopCarAsync();
      _ = CaptureFinalRankAsync();
      StateHasChanged();
      _quizFinished = false;
    }
    else
    {
      _quizFinished = true;
    }
    return Task.CompletedTask;
  }

  private async Task OnLapChanged(int lap)
  {
    _lastLapSeen = lap;
    // Refresh progress bars on each lap crossing
    await UpdateProgressBarsFromRaceAsync();
    // Pull and store updated per-lap telemetry
    try
    {
      List<RaceTrack.LapTelemetry> snaps = new();
      if (_isEasy && _easyRace is not null) snaps = await _easyRace.GetLapTelemetryAsync();
      else if (!_isEasy && _mediumRace is not null) snaps = await _mediumRace.GetLapTelemetryAsync();
      if (snaps.Count > 0)
      {
        // Ensure we keep unique lap numbers, append new ones only
        var known = new HashSet<int>(_telemetry.Select(t => t.Lap));
        foreach (var t in snaps.OrderBy(s => s.Lap))
        {
          if (known.Add(t.Lap)) _telemetry.Add(t);
        }
      }
    }
    catch { }
    if (_quizFinished && _answeredCount > 0 && lap >= _answeredCount)
    {
      _quizFinished = false;
      _raceFinishedUtc ??= DateTime.UtcNow;
      var quizElapsed = (_raceStartedUtc.HasValue && _quizFinishedUtc.HasValue) ? (_quizFinishedUtc.Value - _raceStartedUtc.Value) : TimeSpan.Zero;
      var carElapsed = (_raceStartedUtc.HasValue && _raceFinishedUtc.HasValue) ? (_raceFinishedUtc.Value - _raceStartedUtc.Value) : quizElapsed;
      var maxElapsed = quizElapsed > carElapsed ? quizElapsed : carElapsed;
      try { _quizRef?.RevealElapsedWith(maxElapsed); } catch { }
      _grandPrixFinished = true;
      StopProgressPump();
      _ = StopCarAsync();
      _ = CaptureFinalRankAsync();
      StateHasChanged();
    }
    return;
  }

  private async Task CaptureFinalRankAsync()
  {
    if (!_grandPrixFinished) return; // don't compute final position until race is over
    try
    {
      if (_isEasy && _easyRace is not null)
      {
        var r = await _easyRace.GetUserRankAsync();
        _finalPosition = r.Position;
        _finalTotalCars = r.TotalCars;
      }
      else if (!_isEasy && _mediumRace is not null)
      {
        var r = await _mediumRace.GetUserRankAsync();
        _finalPosition = r.Position;
        _finalTotalCars = r.TotalCars;
      }
      try { _quizRef?.SetExternalPlacement(_finalPosition, _finalTotalCars); } catch { }
      StateHasChanged();
    }
    catch { }
  }

  private async Task StopCarAsync()
  {
    try
    {
      if (_isEasy && _easyRace is not null) await _easyRace.StopAsync();
      else if (!_isEasy && _mediumRace is not null) await _mediumRace.StopAsync();
    }
    catch { }
  }

  private async Task BeginQuizAndRace()
  {
    _showDisclaimer = false;
    StateHasChanged();
    // Defer to next render to ensure overlays are gone before starting
    await Task.Yield();
    try {
      if (_isEasy && _easyRace is not null) await _easyRace.ResetLapTelemetryAsync();
      else if (!_isEasy && _mediumRace is not null) await _mediumRace.ResetLapTelemetryAsync();
    } catch { }
    // Set planned laps before the first step kicks in
    try {
      var total = _quizRef?.GetTotalSteps() ?? 0;
      if (total > 0)
      {
        if (_isEasy && _easyRace is not null) await _easyRace.SetTargetLapsAsync(total);
        else if (!_isEasy && _mediumRace is not null) await _mediumRace.SetTargetLapsAsync(total);
      }
    } catch { }
    // Start the quiz flow; it will trigger OnStepStarted(1) and then start the race step via _easyRace
    _quizRef?.StartFromParent();
    _ = UpdateProgressBarsFromRaceAsync();
    StartProgressPump();
    _raceStartedUtc ??= DateTime.UtcNow;
  }

  private async Task UpdateProgressBarsFromRaceAsync()
  {
    try
    {
      var rivals = new List<double>();
      double you = 0;
      if (_isEasy && _easyRace is not null)
      {
        var ds = await _easyRace.GetCoveredDistancesAsync();
        var u = ds.FirstOrDefault(d => d.IsUser);
        you = Math.Clamp(u?.FractionOfRace ?? 0, 0, 1);
      }
      else if (!_isEasy && _mediumRace is not null)
      {
        var ds = await _mediumRace.GetCoveredDistancesAsync();
        var u = ds.FirstOrDefault(d => d.IsUser);
        you = Math.Clamp(u?.FractionOfRace ?? 0, 0, 1);
        var foes = ds.Where(d => !d.IsUser).OrderBy(d => d.Idx).ToList();
        var want = _quizRef?.GetFoeCount() ?? 5;
        for (int i = 0; i < want; i++)
        {
          var f = (i < foes.Count) ? (foes[i].FractionOfRace ?? 0) : 0;
          rivals.Add(Math.Clamp(f, 0, 1));
        }
      }
      _quizRef?.SetExternalProgress(you, rivals);
    }
    catch { }
  }

  private void StartProgressPump()
  {
    try { StopProgressPump(); } catch { }
    _progressPumpCts = new CancellationTokenSource();
    var ct = _progressPumpCts.Token;
    _ = Task.Run(async () =>
    {
      try
      {
        while (!ct.IsCancellationRequested)
        {
          if (_grandPrixFinished) break;
          await InvokeAsync(UpdateProgressBarsFromRaceAsync);
          await Task.Delay(500, ct);
        }
      }
      catch (OperationCanceledException) { }
      catch { }
    }, ct);
  }

  private void StopProgressPump()
  {
    try { _progressPumpCts?.Cancel(); } catch { }
    try { _progressPumpCts?.Dispose(); } catch { }
    _progressPumpCts = null;
  }

  public void Dispose()
  {
    StopProgressPump();
  }
}
