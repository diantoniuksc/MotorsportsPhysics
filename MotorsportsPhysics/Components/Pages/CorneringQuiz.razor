@page "/cornering-quiz"
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@implements IDisposable
@using System.Linq

<PageTitle>Cornering Dynamics Quiz</PageTitle>

@if (!StepMode)
{
  <div class="container mx-auto px-4 sm:px-6 lg:px-8 pt-0 pb-8">
    <h1 class="text-2xl font-bold mb-4">Cornering Dynamics Quiz</h1>
    <p class="text-gray-700 mb-6">Answer all questions, then click "Check answers" to see your score and explanations.</p>

    @if (submitted)
    {
      <div class="mb-6 rounded-md border border-primary/30 bg-primary/10 px-4 py-3">
        <p class="font-semibold">Score: @CorrectCount / @questions.Count</p>
        @if (UnansweredCount > 0)
        {
          <p class="text-sm text-gray-700">You left @UnansweredCount question(s) unanswered.</p>
        }
      </div>
    }

    <EditForm Model="this" OnValidSubmit="OnSubmit">
      <DataAnnotationsValidator />

      @foreach (var q in questions)
      {
        var chosen = answers.TryGetValue(q.Id, out var sel) ? sel : (int?)null;
        var isCorrect = submitted && chosen is not null && chosen.Value == q.CorrectIndex;
        var isWrong = submitted && chosen is not null && chosen.Value != q.CorrectIndex;
        var isMissing = submitted && chosen is null;

        <fieldset @key=q.Id class="mb-6 rounded-lg border p-4 @(isCorrect ? "border-green-400 bg-green-50" : isWrong ? "border-red-400 bg-red-50" : isMissing ? "border-amber-400 bg-amber-50" : "border-primary/20 bg-background-light")">
          <legend class="px-1 font-semibold">@q.Number. @q.Text</legend>

          <div class="mt-2 space-y-2">
            @for (int i = 0; i < q.Options.Count; i++)
            {
              var opt = q.Options[i];
              var idx = i;
              var selected = chosen.HasValue && chosen.Value == idx;
              <label class="flex items-start gap-3 rounded-md border border-transparent p-2 hover:bg-primary/10 cursor-pointer">
                <input type="radio" name=@($"q{q.Id}") checked="@selected" @onchange="_ => Select(q.Id, idx)" class="mt-1" />
                <span>@opt</span>
              </label>
            }
          </div>

          @if (submitted)
          {
            <div class="mt-3 text-sm">
              @if (isCorrect)
              {
                <p class="text-green-700 font-medium">Correct.</p>
              }
              else if (isWrong)
              {
                <p class="text-red-700 font-medium">Not quite. Correct answer: <strong>@q.LetterFor(q.CorrectIndex)</strong></p>
              }
              else if (isMissing)
              {
                <p class="text-amber-700 font-medium">Answer required. Correct answer: <strong>@q.LetterFor(q.CorrectIndex)</strong></p>
              }

              <div class="mt-2 text-gray-800">
                @((MarkupString)q.GetExplanationHtml())
              </div>
            </div>
          }
        </fieldset>
      }

      <div class="flex gap-3">
        <button type="submit" class="rounded-md bg-primary px-4 py-2 font-semibold text-white hover:bg-opacity-90">Check answers</button>
        <button type="button" class="rounded-md border px-4 py-2 font-semibold hover:bg-gray-50" @onclick="Reset">Reset</button>
      </div>
    </EditForm>
  </div>
}
else
{
  @if (!finished)
  {
    var q = questions[current];
    var chosen = answers.TryGetValue(q.Id, out var sel) ? sel : (int?)null;
    var isCorrect = stepChecked && chosen is not null && chosen.Value == q.CorrectIndex;
    var isWrong = stepChecked && chosen is not null && chosen.Value != q.CorrectIndex;
    var isMissing = stepChecked && chosen is null;

    <div class="bg-background-light rounded-lg border border-primary/20 shadow-lg p-6 max-w-6xl mx-auto">
      @if (RaceMode || Timed)
      {
        <div class="mb-4 flex items-center justify-between">
          @if (Timed)
          {
            <div class="text-sm font-semibold text-primary">Time left: @timeLeft s</div>
          }
          <div class="flex-1 mx-4 h-3 rounded-full bg-primary/10 overflow-hidden">
            <div class="h-full bg-primary/60" style=@($"width:{Math.Round(userProgress*100)}%")></div>
          </div>
          <div class="text-xs text-gray-600">You</div>
        </div>
        <div class="space-y-2 mb-4">
          @for (int i = 0; i < foes.Length; i++)
          {
            var label = (RivalLabels is not null && i < RivalLabels.Length && !string.IsNullOrWhiteSpace(RivalLabels[i]))
              ? RivalLabels[i]
              : $"Rival {i+1}";
            <div class="flex items-center gap-2">
              <div class="flex-1 h-2 rounded-full bg-gray-200 overflow-hidden">
                <div class="h-full bg-gray-500" style=@($"width:{Math.Round(foes[i]*100)}%")></div>
              </div>
              <span class="text-xs text-gray-500">@label</span>
            </div>
          }
        </div>
      }
      <div class="grid gap-6 md:grid-cols-5 md:items-start">
        <div class="md:col-span-2">
          <p class="text-primary font-bold text-sm mb-1">Question @(@current + 1)/@questions.Count</p>
          <p class="text-lg font-bold text-gray-800">@q.Text</p>
        </div>
  <div class="w-full md:col-span-3 space-y-3">
          @for (int i = 0; i < q.Options.Count; i++)
          {
            var opt = q.Options[i];
            var idx = i;
            var selected = chosen.HasValue && chosen.Value == idx;
            <label class="flex items-center gap-4 rounded-lg border border-primary/20 p-4 hover:bg-primary/10 cursor-pointer transition-all">
              <input type="radio" name=@($"q{q.Id}") class="h-5 w-5" checked="@selected" @onchange="_ => Select(q.Id, idx)" />
              <span class="text-sm font-medium">@opt</span>
            </label>
          }
        </div>
      </div>

      @if (stepChecked)
      {
        <div class="mt-4 text-sm">
          @if (isCorrect)
          {
            <p class="text-green-700 font-semibold">Correct.</p>
          }
          else if (isWrong)
          {
            <p class="text-red-700 font-semibold">Not quite. Correct answer: <strong>@q.LetterFor(q.CorrectIndex)</strong></p>
          }
          else if (isMissing)
          {
            <p class="text-amber-700 font-semibold">Answer required. Correct answer: <strong>@q.LetterFor(q.CorrectIndex)</strong></p>
          }
          @if (ShowExplanation)
          {
            <div class="mt-2 text-gray-800">@((MarkupString)q.GetExplanationHtml())</div>
          }
        </div>
      }

      <div class="flex justify-center mt-6 gap-3">
        @if (!stepChecked)
        {
          <button class="w-full md:w-auto flex min-w-[120px] items-center justify-center rounded-lg h-11 px-6 bg-primary text-white text-sm font-bold tracking-wider disabled:opacity-50"
                  disabled="@(chosen is null)" @onclick="CheckCurrent">
            <span>Check answer</span>
          </button>
        }
        else
        {
          var isLast = current >= questions.Count - 1;
          var canFinish = !RaceMode || !isLast || (userProgress >= 0.999 && foes.All(f => f >= 0.999));
          <button class="w-full md:w-auto flex min-w-[120px] items-center justify-center rounded-lg h-11 px-6 bg-primary text-white text-sm font-bold tracking-wider disabled:opacity-50"
                  disabled="@(!canFinish)" @onclick="Next">
            <span>@(isLast ? "Finish" : "Next")</span>
          </button>
        }
      </div>
    </div>
  }
  else
  {
    <div class="max-w-3xl mx-auto rounded-lg border border-primary/30 bg-primary/10 px-4 py-6 text-center">
      <p class="text-xl font-semibold">Score: @CorrectCount / @questions.Count</p>
      @if (_elapsed.HasValue && _showElapsed)
      {
        <p class="mt-2 text-gray-800">Time to complete: <strong>@_elapsed.Value.ToString(@"m\:ss")</strong></p>
      }
      else if (finished && !_showElapsed)
      {
        <p class="mt-2 text-gray-600 text-sm">Waiting for car to complete the final lap…</p>
      }
      @if (RaceMode)
      {
            if (_externalPlacement.HasValue)
            {
              var pos = _externalPlacement!.Value;
              var tot = Math.Max(1, _externalTotalCars > 0 ? _externalTotalCars : foes.Length + 1);
              <p class="mt-2 text-gray-800 font-medium">
                Race result: @(pos == 1 ? "You won!" : $"You finished {pos} of {tot}")
              </p>
            }
            else
            {
              var placement = 1 + foes.Count(f => f > userProgress);
              <p class="mt-2 text-gray-800 font-medium">
                Race result: @(placement == 1 ? "You won!" : $"You finished {placement} of {foes.Length + 1}")
              </p>
            }
      }
      <div class="mt-4 flex justify-center gap-3">
        <button class="rounded-lg border px-4 py-2 font-semibold hover:bg-gray-50" @onclick="ResetAndStart">Try again</button>
        <a class="rounded-lg bg-primary text-white px-4 py-2 font-semibold" href="/race-menu">Back to menu</a>
      </div>
    </div>
  }
}

@code {
  private bool submitted = false;
  private Dictionary<int, int> answers = new();
  [Parameter] public bool StepMode { get; set; } = false;
  [Parameter] public bool ShowExplanation { get; set; } = true;
  [Parameter] public bool RaceMode { get; set; } = false;
  [Parameter] public bool Timed { get; set; } = false;
  // Difficulty label passed by parent (e.g., "Easy", "Medium", "High"). Default Easy.
  [Parameter] public string Difficulty { get; set; } = "Easy";
  // When true (default), the quiz in StepMode will auto-start on first render.
  // Set to false to defer starting until the parent explicitly calls StartFromParent().
  [Parameter] public bool AutoStart { get; set; } = true;
  // Raised when a step (question) is shown; argument is 1-based step number
  [Parameter] public EventCallback<int> OnStepStarted { get; set; }
  // Raised whenever the current question becomes answered or unanswered
  [Parameter] public EventCallback<bool> OnAnswerStateChanged { get; set; }
  // Raised when the user presses "Check answer" in StepMode indicating whether it was correct
  [Parameter] public EventCallback<bool> OnAnswerChecked { get; set; }
  // Raised with total answered count whenever it changes (counts any answered, not only correct)
  [Parameter] public EventCallback<int> OnAnsweredCountChanged { get; set; }
  // Raised when the user completes all questions in StepMode; parent can wait for race finish
  [Parameter] public EventCallback OnFinished { get; set; }
  [Parameter] public int TimeLimitSeconds { get; set; } = 90;
  private int current = 0;
  private bool stepChecked = false;
  private bool finished = false;
  private bool started = false;
  private DateTime? _startedUtc;
  private DateTime? _finishedUtc;
  private TimeSpan? _elapsed;
  private bool _showElapsed = false;
  private int? _externalPlacement;
  private int _externalTotalCars = 0;
  private int timeLeft;
  private System.Timers.Timer? _timer;
  private double userProgress = 0; // 0..1
  [Parameter] public string[] RivalLabels { get; set; } = System.Array.Empty<string>();
  // Five rivals' relative progress (0..1) and per-step base pace multipliers (matches Medium race cars)
  private double[] foes = new double[5] { 0, 0, 0, 0, 0 };
  private double[] foeBase = new double[5] { 0.95, 0.92, 0.90, 0.88, 0.85 }; // relative pace per question step
  private readonly Random _rng = new Random();
  // Tracks which question IDs have been explicitly submitted (via Check answer) in StepMode
  private HashSet<int> committed = new();

  // The active list of questions for the current difficulty
  private List<Question> questions = new();

  // Easy (and default) question set
  private readonly List<Question> _easyQuestions = new()
  {
    new(1, "What is the difference between understeer and oversteer?",
      new() {
        "A) Understeer happens when the rear tires lose grip first, oversteer when the front tires lose grip first",
        "B) Understeer happens when the front tires lose grip first, oversteer when the rear tires lose grip first",
        "C) Both understeer and oversteer mean all tires lose grip at the same time",
        "D) Oversteer and understeer are the same phenomenon"
      }, 1,
      explanationHtml: "Understeer: front tires saturate first so the car runs wide. Oversteer: rear tires saturate first so the rear steps out."),

    new(2, "Which force keeps a car moving in a circular path during cornering?",
      new() { "A) Centrifugal force", "B) Centripetal force", "C) Inertia", "D) Gravitational force" }, 1,
      explanationHtml: "Centripetal force acts toward the center of the turn to continuously change the car’s direction."),

    new(3, "Why do Formula 1 cars rely heavily on aerodynamic downforce when cornering?",
      new() { "A) To reduce fuel consumption", "B) To increase tire wear", "C) To increase grip and allow higher cornering speeds", "D) To decrease car weight" }, 2,
      explanationHtml: "Downforce increases normal load on the tires, increasing available frictional (lateral) force without increasing mass."),

    new(4, "A car of mass 800 kg takes a corner of radius 50 m at 20 m/s. What is the required centripetal force?",
      new() { "A) 3,200 N", "B) 4,800 N", "C) 6,400 N", "D) 64,000 N" }, 2,
      calculation: q => {
        double m=800, v=20, r=50; var Fc = m * v * v / r; // 6400 N
        return $"Centripetal force F = m v^2 / r = 800 · 20^2 / 50 = 800 · 400 / 50 = 320,000 / 50 = <strong>{Fc:N0} N</strong>.";
      }),

    new(5, "What limits the maximum speed at which a car can safely take a corner?",
      new() { "A) Engine power", "B) Tire grip (friction coefficient)", "C) Car weight", "D) Aerodynamic drag" }, 1,
      explanationHtml: "Maximum cornering is limited when required lateral force m v^2 / r reaches the tire friction limit μ N (grip)."),

    new(6, "Why do racing cars use wider tires than normal road cars?",
      new() { "A) To look more aggressive", "B) To reduce air resistance", "C) To increase the contact patch and improve grip", "D) To reduce suspension stiffness" }, 2,
      explanationHtml: "Wider tires generally enable a larger, more stable contact patch and better heat management, improving usable grip."),

    new(7, "What happens to weight distribution during cornering?",
      new() { "A) More weight transfers to the inside tires", "B) More weight transfers to the outside tires", "C) Weight distribution stays the same", "D) Weight transfers to the rear tires" }, 1,
      explanationHtml: "Lateral acceleration causes load transfer to the outside tires via the suspension and roll geometry."),

    new(8, "If μ = 1.2, corner radius = 40 m, g = 9.81 m/s², what is the maximum safe cornering speed?",
      new() { "A) 15.6 m/s", "B) 21.7 m/s", "C) 30.5 m/s", "D) 35.0 m/s" }, 1,
      calculation: q => {
        double mu=1.2, r=40, g=9.81; var v = Math.Sqrt(mu * g * r); // ~21.7
        return $"Speed limit from μ g r = v² → v = √(μ g r) = √(1.2 · 9.81 · 40) = √(470.88) ≈ <strong>{v:F1} m/s</strong>.";
      }),

    new(9, "What role does the suspension system play in cornering dynamics?",
      new() { "A) Increases top speed", "B) Maintains tire contact with the road for better grip", "C) Reduces aerodynamic drag", "D) Transfers engine power to the wheels" }, 1,
      explanationHtml: "Suspension geometry and damping keep tires in good contact and manage load transfer for predictable grip."),

    new(10, "Why do racing drivers take a “racing line” through corners?",
      new() { "A) To make the corner longer, reducing sharpness", "B) To stay closer to the audience", "C) To save tire life", "D) To reduce the need for braking completely" }, 0,
      explanationHtml: "A wider radius reduces required lateral acceleration (m v^2 / r), enabling higher corner speed and stability."),
  };

  // Medium question set (user-provided list)
  private readonly List<Question> _mediumQuestions = new()
  {
    new(1, "What does the term \"slip angle\" describe in cornering?",
      new() {
        "A) The angle between the car’s direction of travel and the steering wheel position",
        "B) The angle between the tire’s actual path and its pointing direction",
        "C) The angle of the car’s roll while cornering",
        "D) The maximum angle a car can turn before skidding"
      }, 1),

    new(2, "What happens when a driver enters a corner too fast?",
      new() {
        "A) The car always spins",
        "B) The car tends to understeer or oversteer, depending on grip",
        "C) The car automatically stabilizes due to inertia",
        "D) The tires gain more grip"
      }, 1),

    new(3, "Why is the apex important when taking a racing corner?",
      new() {
        "A) It is the point where braking starts",
        "B) It minimizes the steering input needed",
        "C) It reduces engine wear",
        "D)  It is the point closest to the inside of the corner that helps optimize speed"
      }, 3),

    new(4, "What is trail braking in racing?",
      new() {
        "A) Braking only before the corner",
        "B) Braking throughout the entire straight",
        "C) Gradually releasing the brake while entering the corner",
        "D) Using the handbrake to initiate cornering"
      }, 2),

    new(5, "Which of these factors increases cornering grip?",
      new() {
        "A) Increased aerodynamic downforce",
        "B) Lower car mass",
        "C)  Higher tire pressure",
        "D) Shorter wheelbase"
      }, 0),

    new(6, "What happens to lateral acceleration when corner radius decreases but speed stays the same?",
      new() {
        "A) It decreases",
        "B) It increases",
        "C) It stays the same",
        "D) It becomes zero"
      }, 1),

    new(7, "What role does camber angle play in cornering?",
      new() {
        "A) It affects tire temperature",
        "B) It reduces braking distance",
        "C) It optimizes tire contact patch for better grip",
        "D) It increases aerodynamic drag"
      }, 2),

    new(8, "Why do cars lean outward during a turn?",
      new() {
        "A) Due to aerodynamic forces",
        "B) Due to centrifugal effect (inertia)",
        "C) Due to reduced tire pressure",
        "D) Due to suspension stiffness"
      }, 1),

    new(9, "Which cornering technique helps maintain maximum speed through a curve?",
      new() {
        "A) Braking late and accelerating early",
        "B) Taking a wide entry, hitting the apex, and wide exit",
        "C) Steering sharply into the corner",
        "D) Reducing steering angle completely"
      }, 1),

    new(10, "Why is tire load sensitivity important in cornering?",
      new() {
        "A) Because tires generate more grip as load increases, but not proportionally",
        "B) Because tires lose grip with increased load",
        "C) Because load has no effect on grip",
        "D) Because load sensitivity only applies to braking"
      }, 0),
  };

  private void Select(int id, int optionIndex)
  {
    answers[id] = optionIndex;
    // In StepMode, do not advance or notify gating on selection alone; submit happens on CheckCurrent
    if (!StepMode)
    {
      var q = questions[current];
      var has = answers.ContainsKey(q.Id);
      _ = OnAnswerStateChanged.InvokeAsync(has);
      _ = OnAnsweredCountChanged.InvokeAsync(answers.Count);
    }
  }

  // Helpers for InputRadioGroup binding
  private int? GetAnswer(int id)
  {
    return answers.TryGetValue(id, out var a) ? a : (int?)null;
  }

  private void SelectNullable(int id, int? value)
  {
    if (value.HasValue)
    {
      answers[id] = value.Value;
    }
    else
    {
      answers.Remove(id);
    }
    if (!StepMode)
    {
      var q = questions[current];
      var has = answers.ContainsKey(q.Id);
      _ = OnAnswerStateChanged.InvokeAsync(has);
      _ = OnAnsweredCountChanged.InvokeAsync(answers.Count);
    }
  }

  private int CorrectCount => questions.Count(q => answers.TryGetValue(q.Id, out var a) && a == q.CorrectIndex);
  private int UnansweredCount => questions.Count(q => !answers.ContainsKey(q.Id));

  private void OnSubmit()
  {
    submitted = true;
  }

  private void Reset()
  {
    submitted = false;
    answers.Clear();
    committed.Clear();
    _externalPlacement = null;
    _externalTotalCars = 0;
  }

  private void ResetAndStart()
  {
    Reset();
    current = 0;
    stepChecked = false;
    finished = false;
    _startedUtc = DateTime.UtcNow;
    _finishedUtc = null;
    _elapsed = null;
  userProgress = 0; for (int i = 0; i < foes.Length; i++) foes[i] = 0; started = true;
    if (Timed)
    {
      StartTimer();
    }
    // Notify that step 1 is now active
    _ = OnStepStarted.InvokeAsync(current + 1);
    // On a new question start, notify answered state (likely false)
    var q = questions[current];
    var has = answers.ContainsKey(q.Id);
    _ = OnAnswerStateChanged.InvokeAsync(has && !StepMode ? has : false);
    _ = OnAnsweredCountChanged.InvokeAsync(StepMode ? committed.Count : answers.Count);
  }

  private void CheckCurrent()
  {
    stepChecked = true;
    // In StepMode, a submission commits the current question and notifies gating to resume
    if (StepMode)
    {
      var q = questions[current];
      committed.Add(q.Id);
      _ = OnAnswerStateChanged.InvokeAsync(true);
      // Also notify correctness result for game logic (e.g., speed penalty on wrong answers)
      var chosenOk = answers.TryGetValue(q.Id, out var a) && a == q.CorrectIndex;
      _ = OnAnswerChecked.InvokeAsync(chosenOk);
      _ = OnAnsweredCountChanged.InvokeAsync(committed.Count);
    }
  }

  private async Task Next()
  {
  if (current < questions.Count - 1)
    {
      // progress: only correct answers advance the player
      if (answers.TryGetValue(questions[current].Id, out var a) && a == questions[current].CorrectIndex)
      {
        userProgress = Math.Min(1, userProgress + (1.0 / questions.Count));
      }
      // opponents advance a bit each step
      for (int i = 0; i < foes.Length; i++)
      {
        var jitter = 0.8 + _rng.NextDouble() * 0.4; // 0.8..1.2
        foes[i] = Math.Min(1, foes[i] + foeBase[i] * (1.0 / questions.Count) * jitter);
      }
      current++;
      stepChecked = false;
      // Notify new step now visible
      _ = OnStepStarted.InvokeAsync(current + 1);
      var q2 = questions[current];
      var has2 = answers.ContainsKey(q2.Id);
      _ = OnAnswerStateChanged.InvokeAsync(StepMode ? false : has2);
      _ = OnAnsweredCountChanged.InvokeAsync(StepMode ? committed.Count : answers.Count);
    }
    else
    {
      // last question: finalize progress once
      if (answers.TryGetValue(questions[current].Id, out var a) && a == questions[current].CorrectIndex)
      {
        userProgress = Math.Min(1, userProgress + (1.0 / questions.Count));
      }
      for (int i = 0; i < foes.Length; i++)
      {
        var jitter = 0.8 + _rng.NextDouble() * 0.4;
        foes[i] = Math.Min(1, foes[i] + foeBase[i] * (1.0 / questions.Count) * jitter);
      }
      await FinishAsync();
    }
  }

  private void StartTimer()
  {
    StopTimer();
    timeLeft = TimeLimitSeconds;
    _timer = new System.Timers.Timer(1000);
    _timer.Elapsed += async (_, __) =>
    {
      if (finished) { StopTimer(); return; }
      timeLeft = Math.Max(0, timeLeft - 1);
      // advance opponents each tick
      for (int i = 0; i < foes.Length; i++)
      {
        var tickInc = foeBase[i] * (1.0 / (questions.Count * Math.Max(10, TimeLimitSeconds))); // small per-second bumps
        foes[i] = Math.Min(1, foes[i] + tickInc);
      }
      if (timeLeft == 0)
      {
        await FinishAsync();
      }
      await InvokeAsync(StateHasChanged);
    };
    _timer.AutoReset = true;
    _timer.Enabled = true;
  }

  private void StopTimer()
  {
    if (_timer is not null)
    {
      try { _timer.Stop(); _timer.Dispose(); } catch { }
      _timer = null;
    }
  }

  // --- External race integration helpers ---
  public int GetTotalSteps() => questions.Count;
  public int GetFoeCount() => foes.Length;
  private static double Clamp01(double v) => v < 0 ? 0 : (v > 1 ? 1 : v);
  public void SetExternalProgress(double youFraction, IReadOnlyList<double> rivalsFractions)
  {
    userProgress = Clamp01(youFraction);
    for (int i = 0; i < foes.Length; i++)
    {
      var f = (i < rivalsFractions.Count) ? rivalsFractions[i] : 0.0;
      foes[i] = Clamp01(f);
    }
    InvokeAsync(StateHasChanged);
  }

  protected override void OnAfterRender(bool firstRender)
  {
    if (firstRender && StepMode && !started && AutoStart)
    {
      ResetAndStart();
    }
    base.OnAfterRender(firstRender);
  }

  protected override void OnParametersSet()
  {
    // Select questions based on difficulty; default to Easy for unknown values.
    var d = (Difficulty ?? "Easy").Trim();
    var isMedium = d.Equals("Medium", StringComparison.OrdinalIgnoreCase);
    var isEasy = d.Equals("Easy", StringComparison.OrdinalIgnoreCase);
    // High currently uses Easy questions unless a separate set is added later
    questions = isMedium ? _mediumQuestions : _easyQuestions;
    base.OnParametersSet();
  }

  public void Dispose()
  {
    StopTimer();
  }

  // Allow parent to explicitly start the StepMode flow when AutoStart is false
  public void StartFromParent()
  {
    if (!started)
    {
      ResetAndStart();
    }
  }

  // Emit completion: compute elapsed immediately (quiz duration), but defer showing until parent reveals
  private async Task FinishAsync()
  {
    if (!finished)
    {
      finished = true;
    }
    _finishedUtc ??= DateTime.UtcNow;
    _elapsed = (_startedUtc.HasValue) ? _finishedUtc.Value - _startedUtc.Value : null;
    _showElapsed = false; // hide until race finishes
    StopTimer();
    await InvokeAsync(StateHasChanged);
    try { if (OnFinished.HasDelegate) await OnFinished.InvokeAsync(); } catch { }
  }

  // Called by parent when the race completes its final lap to reveal the elapsed time
  public void RevealElapsed()
  {
    _showElapsed = true;
    InvokeAsync(StateHasChanged);
  }

  // Called by parent to set a specific elapsed value and reveal it (e.g., max of quiz vs. car time)
  public void RevealElapsedWith(TimeSpan elapsed)
  {
    _elapsed = elapsed;
    _showElapsed = true;
    InvokeAsync(StateHasChanged);
  }

  // Called by parent to set the authoritative final placement from the race engine
  public void SetExternalPlacement(int position, int totalCars)
  {
    _externalPlacement = position;
    _externalTotalCars = totalCars;
    InvokeAsync(StateHasChanged);
  }

  private record Question(int Number, string Text, List<string> Options, int CorrectIndex, Func<Question, string>? calculation = null, string? explanationHtml = null)
  {
    public int Id => Number;
    public string LetterFor(int idx) => ((char)('A' + idx)).ToString();
    public string GetExplanationHtml()
    {
      if (calculation is not null)
      {
        return calculation(this);
      }
      return explanationHtml ?? string.Empty;
    }
  }
}
